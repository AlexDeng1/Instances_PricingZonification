import pandas as pd
import numpy as np
import csv
from mode_selection_vots import mode_selection
import Instance_generation.args as args

"""
# Retrieve input data
"""
input_filepath = '../Input_data/'
output_filepath = '../New_Instances/'
# Trips generated from Points of Interest (POIs) scratched from Google Map APIs
trips_df = pd.read_csv(input_filepath+ 'trips_toModes.csv')
# Set of real-world carsharing stations in Copenhagen
css_df = pd.read_csv(input_filepath+ 'css_distance_matrix.csv')
# Travellers generated by choosing two distiguished Points of Interest (POIs) as origin and destination
traveller_df = pd.read_csv(input_filepath + 'travellers_fromPOIs.csv')

# carsharing station list
cs_stations = ['CS'+str(i) for i in range(20)]

def instance_cus_gen(args_set):
    cus_indices = ['traveller_id', 'cus_o', 'cus_d', 'highest_pl', 'whether_request']
    # create an empty dataframe to store potential customer data
    selected_traveller_info = []

    cus_generator = mode_selection(cs_stations, traveller_df, args_set.num_of_customers, args_set.mu_sv,
                                   args_set.sd_sv, args_set.mu_others, args_set.sd_others, args_set.mu_ww, args_set.sd_ww,
                                   args_set.wwt_public, args_set.taxi_wt, args_set.num_of_selected_css, trips_df, seed=args_set.seed_number)

    # retrieve potential customers data
    # selected_travellers: a list of potential customers that choose stations from selected_css as origin and destination carsharing stations
    selected_css, selected_travellers = cus_generator.selected_data()

    # generate requests based on travellers' utilities of all transport modes
    # the generated requests are stored in customer_requests dictionary
    vot_sv, vot_others, vot_ww = cus_generator.vot_dict_generator(selected_travellers)
    customer_requests = cus_generator.cs_customer_generator(selected_travellers, vot_sv, vot_others, vot_ww, args_set.pricing_levels,
                                                            args_set.cs_min_fee, args_set.public_ticket, args_set.taxi_fee)

    for traveller in selected_travellers:
        whether_request = 'N'
        highest_pl = 'None'      # highest acceptable pricing level of choosing carsharing
        idx = traveller_df[traveller_df['traveller_id'] == traveller].index.tolist()[0]
        css_o = traveller_df.iloc[idx]['css_o']  # obtain the origin station information
        css_d = traveller_df.iloc[idx]['css_d']  # obtain the destination station information
        if traveller in customer_requests.keys():
            whether_request = 'Y'
            highest_pl = customer_requests[traveller][1]

        selected_traveller_info.append((traveller, css_o, css_d, highest_pl, whether_request))

    # store instance data on travellers' information into cus_df dataframe
    cus_df = pd.DataFrame(selected_traveller_info, columns=cus_indices)
    return cus_df, customer_requests

def instance_veh_gen(args_set, customer_requests):
    cus_at_station = {css: 0 for css in cs_stations}
    for cus in customer_requests.keys():
        idx = traveller_df[traveller_df['traveller_id'] == cus].index.tolist()[0]
        cus_o = traveller_df.iloc[idx]['css_o']  # obtain the origin station information
        cus_at_station[cus_o] += 1

    # create a set of shared vehicles with the number of 'num_of_vehicles'
    shared_vehicles = ['sv'+ str(i) for i in range(args_set.num_of_vehicles)]
    shared_vehicle_for_centralized_choice = shared_vehicles[0:]

    vehicle_initial_loc = {sv: 0 for sv in shared_vehicles}

    # initialize the vehicle initial allocation decisions
    veh_allocation = {(sv, css): 0 for sv in shared_vehicles for css in cs_stations}

    # INITIAL LOCATION BASED ON DENSITY
    for css in cs_stations:
        sv_quantity = np.round(
            cus_at_station[css] / len(customer_requests) * len(shared_vehicle_for_centralized_choice))
        sv_selected_for_css = np.random.choice(shared_vehicle_for_centralized_choice,
                                               size=min(int(sv_quantity), len(shared_vehicle_for_centralized_choice)),
                                               replace=False)
        for sv in sv_selected_for_css:
            vehicle_initial_loc[sv] = css
            veh_allocation[(sv, css)] = 1
            shared_vehicle_for_centralized_choice.remove(sv)

    while shared_vehicle_for_centralized_choice:
        for sv in shared_vehicle_for_centralized_choice:
            assigned_css = np.random.choice(cs_stations)
            vehicle_initial_loc[sv] = assigned_css
            veh_allocation[(sv, assigned_css)] = 1
            shared_vehicle_for_centralized_choice.remove(sv)

    return vehicle_initial_loc



if __name__ == "__main__":
    args_set = args.get_args()

    # set parameters
    args_set.num_of_customers = 800
    args_set.num_of_vehicles = 400
    args_set.num_of_zones = '-'
    args_set.num_of_selected_css = 20

    cus_df, customer_requests = instance_cus_gen(args_set)
    vehicle_initial_loc = instance_veh_gen(args_set, customer_requests)

    for seed in args_set.seed_numbers:
        args_set.seed_number = seed
        args_set.name_of_instance = 'K' + str(args_set.num_of_customers) + 'V' + str(
            args_set.num_of_vehicles) + 'seed' + str(args_set.seed_number)
        print("--- Generate instance ---", args_set.name_of_instance)
        instance_file_path = None
        if args_set.num_of_selected_css == 10:
            instance_file_path = output_filepath+'small_instances/'+args_set.name_of_instance+'.csv'
        else:
            instance_file_path = output_filepath + 'larger_instances/' + args_set.name_of_instance + '.csv'


        # Append the new data
        with open(instance_file_path, 'a', newline='') as csvfile:
            writer = csv.writer(csvfile)
            # write the header line for customer information
            writer.writerow( ['traveller_id', 'cus_o', 'cus_d', 'highest_pl', 'whether_request'])
            for row in range(len(cus_df)):
                writer.writerow(cus_df.iloc[row])

            # write the header line for the vehicles
            writer.writerow(['vehicle_id', 'loc_css'])
            for veh in vehicle_initial_loc.keys():
                veh_loc = vehicle_initial_loc[veh]
                writer.writerow([veh, veh_loc])





